// Generated by CoffeeScript 1.6.2
/*
Interval Tree

Based on
[1] BSTree https://github.com/mauriciosantos/buckets
[2] Introduction to algorithms / Thomas H. Cormen . . . [et al.].—3rd ed., The MIT Press, ISBN 978-0-262-03384-8
        Section 14.3: Interval trees, pp. 348–354
[3] http://en.wikipedia.org/wiki/Interval_tree#Augmented_tree
*/


(function() {
  var intervalComparator;

  intervalComparator = function(a, b) {
    if (a.low < b.low) {
      return -1;
    } else if (a.low > b.low) {
      return 1;
    } else {
      if (a.high < b.high) {
        return -1;
      } else if (a.high > b.high) {
        return 1;
      } else {
        return 0;
      }
    }
  };

  Ext.define('Sch.lib.IntervalBsTree', {
    root: null,
    comparator: intervalComparator,
    statics: {
      createInterval: function(low, high, tag) {
        return {
          low: low,
          high: high,
          tag: tag
        };
      }
    },
    constructor: function() {
      return this;
    },
    add: function(interval) {
      var node;

      if (!interval) {
        return false;
      }
      node = {
        interval: interval,
        max: interval.high,
        left: null,
        right: null,
        parent: null
      };
      return this._insertNode(node) !== null;
    },
    query: function(point) {
      var current, interval, node, prev, result;

      result = [];
      node = this.root;
      prev = null;
      current = void 0;
      interval = void 0;
      while (node != null) {
        current = node;
        if (prev === node.parent) {
          if (point > node.max) {
            node = current.parent;
            prev = current;
            continue;
          }
          if (node.left != null) {
            node = current.left;
            prev = current;
            continue;
          }
          interval = node.interval;
          if (point < interval.low) {
            node = current.parent;
            prev = current;
            continue;
          }
          if (point <= interval.high) {
            result.push(interval);
          }
          node = ((node.right != null) ? current.right : current.parent);
          prev = current;
          continue;
        } else {
          if (prev === node.left) {
            interval = node.interval;
            if (point < interval.low) {
              node = current.parent;
              prev = current;
              continue;
            }
            if (point <= interval.high) {
              result.push(interval);
            }
            if (node.right != null) {
              node = current.right;
              prev = current;
              continue;
            }
          }
          node = current.parent;
          prev = current;
          continue;
        }
      }
      return result;
    },
    _insertNode: function(node) {
      var cmp, position;

      if (this.root === null) {
        this.root = node;
        return node;
      }
      position = this.root;
      cmp = null;
      while (true) {
        cmp = this.comparator(node.interval, position.interval);
        if (cmp === 0) {
          return null;
        } else if (cmp < 0) {
          if (position.left === null) {
            node.parent = position;
            position.left = node;
            this._updateMax(node);
            return node;
          } else {
            position = position.left;
          }
        } else {
          if (position.right === null) {
            node.parent = position;
            position.right = node;
            this._updateMax(node);
            return node;
          } else {
            position = position.right;
          }
        }
      }
    },
    _updateMax: function(node) {
      node.max = Math.max(node.interval.high, (node.left ? node.left.max : -Number.MAX_VALUE), (node.right ? node.right.max : -Number.MAX_VALUE));
      if (node.parent && node.parent.max < node.max) {
        return this._updateMax(node.parent);
      }
    },
    _searchNode: function(node, interval) {
      var cmp;

      cmp = null;
      while (node !== null && cmp !== 0) {
        cmp = this.comparator(interval, node.interval);
        if (cmp < 0) {
          node = node.left;
        } else {
          if (cmp > 0) {
            node = node.right;
          }
        }
      }
      return node;
    },
    _transplant: function(n1, n2) {
      if (n1.parent === null) {
        this.root = n2;
      } else if (n1 === n1.parent.left) {
        n1.parent.left = n2;
      } else {
        n1.parent.right = n2;
      }
      if (n2 !== null) {
        n2.parent = n1.parent;
        if (n2.parent !== null) {
          return this._updateMax(n2.parent);
        }
      }
    },
    _minimumAux: function(node) {
      while (node.left !== null) {
        node = node.left;
      }
      return node;
    },
    _maximumAux: function(node) {
      while (node.right !== null) {
        node = node.right;
      }
      return node;
    },
    _successorNode: function(node) {
      var successor;

      if (node.right !== null) {
        return this._minimumAux(node.right);
      }
      successor = node.parent;
      while (successor !== null && node === successor.right) {
        node = successor;
        successor = node.parent;
      }
      return successor;
    },
    _heightAux: function(node) {
      if (node === null) {
        return -1;
      }
      return Math.max(this._heightAux(node.left), this._heightAux(node.right)) + 1;
    },
    _removeNode: function(node) {
      var y;

      if (node.left === null) {
        return this._transplant(node, node.right);
      } else if (node.right === null) {
        return this._transplant(node, node.left);
      } else {
        y = this._minimumAux(node.right);
        if (y.parent !== node) {
          this._transplant(y, y.right);
          y.right = node.right;
          y.right.parent = y;
          this._updateMax(y);
        }
        this._transplant(node, y);
        y.left = node.left;
        y.left.parent = y;
        return this._updateMax(y);
      }
    },
    _inorderTraversalAux: function(node, callback, signal) {
      if (node === null || signal.stop) {
        return;
      }
      this._inorderTraversalAux(node.left, callback, signal);
      if (signal.stop) {
        return;
      }
      signal.stop = callback(node.interval) === false;
      if (signal.stop) {
        return;
      }
      return this._inorderTraversalAux(node.right, callback, signal);
    },
    _preorderTraversalAux: function(node, callback, signal) {
      if (node === null || signal.stop) {
        return;
      }
      signal.stop = callback(node.interval) === false;
      if (signal.stop) {
        return;
      }
      this._preorderTraversalAux(node.left, callback, signal);
      if (signal.stop) {
        return;
      }
      return this._preorderTraversalAux(node.right, callback, signal);
    },
    _postorderTraversalAux: function(node, callback, signal) {
      if (node === null || signal.stop) {
        return;
      }
      this._postorderTraversalAux(node.left, callback, signal);
      if (signal.stop) {
        return;
      }
      this._postorderTraversalAux(node.right, callback, signal);
      if (signal.stop) {
        return;
      }
      return signal.stop = callback(node.interval) === false;
    },
    clear: function() {
      return this.root = null;
    },
    isEmpty: function() {
      return this.root === null;
    },
    contains: function(interval) {
      if (!interval) {
        return false;
      }
      return this._searchNode(this.root, interval) !== null;
    },
    remove: function(interval) {
      var node;

      node = this._searchNode(this.root, interval);
      if (node === null) {
        return false;
      }
      this._removeNode(node);
      return true;
    },
    inorderTraversal: function(callback) {
      return this._inorderTraversalAux(this.root, callback, {
        stop: false
      });
    },
    preorderTraversal: function(callback) {
      return this._preorderTraversalAux(this.root, callback, {
        stop: false
      });
    },
    postorderTraversal: function(callback) {
      return this._postorderTraversalAux(this.root, callback, {
        stop: false
      });
    },
    minimum: function() {
      if (this.isEmpty()) {
        return void 0;
      }
      return this._minimumAux(this.root).interval;
    },
    maximum: function() {
      if (this.isEmpty()) {
        return void 0;
      }
      return this._maximumAux(this.root).interval;
    },
    forEach: function(callback) {
      return this.inorderTraversal(callback);
    },
    toArray: function() {
      var array;

      array = [];
      this.inorderTraversal(function(interval) {
        return array.push(interval);
      });
      return array;
    },
    height: function() {
      return this._heightAux(this.root);
    }
  });

}).call(this);

/*
//@ sourceMappingURL=IntervalBsTree.map
*/
