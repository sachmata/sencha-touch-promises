// Generated by CoffeeScript 1.6.2
/* 
Interval Tree

Based on
[1] AvlTree http://docs.closure-library.googlecode.com/git/class_goog_structs_AvlTree.html
[2] Introduction to algorithms / Thomas H. Cormen . . . [et al.].—3rd ed., The MIT Press, ISBN 978-0-262-03384-8
        Section 14.3: Interval trees, pp. 348–354
[3] http://en.wikipedia.org/wiki/Interval_tree#Augmented_tree
*/


(function() {
  var intervalComparator;

  intervalComparator = function(a, b) {
    if (a.low < b.low) {
      return -1;
    } else if (a.low > b.low) {
      return 1;
    } else {
      if (a.high < b.high) {
        return -1;
      } else if (a.high > b.high) {
        return 1;
      } else {
        return 0;
      }
    }
  };

  Ext.define('Sch.lib.IntervalAvlTree', {
    comparator_: intervalComparator,
    root_: null,
    minNode_: null,
    maxNode_: null,
    statics: {
      createValue: function(low, high, tag) {
        return {
          low: low,
          high: high,
          tag: tag
        };
      }
    },
    constructor: function() {
      return this;
    },
    add: function(value) {
      var newNode, oldNode;

      if (this.root_ == null) {
        this.root_ = new Sch.lib.IntervalAvlTreeNode(value);
        this.minNode_ = this.root_;
        this.maxNode_ = this.root_;
        return this.root_.value;
      }
      newNode = null;
      oldNode = null;
      this.traverse_(function(node) {
        var retNode;

        retNode = null;
        if (this.comparator_(node.value, value) > 0) {
          retNode = node.left;
          if (node.left == null) {
            newNode = new Sch.lib.IntervalAvlTreeNode(value, node);
            node.left = newNode;
            if (node === this.minNode_) {
              this.minNode_ = newNode;
            }
          }
        } else if (this.comparator_(node.value, value) < 0) {
          retNode = node.right;
          if (node.right == null) {
            newNode = new Sch.lib.IntervalAvlTreeNode(value, node);
            node.right = newNode;
            if (node === this.maxNode_) {
              this.maxNode_ = newNode;
            }
          }
        } else {
          oldNode = node;
        }
        return retNode;
      });
      if (newNode) {
        this.traverse_((function(node) {
          node.count++;
          return node.parent;
        }), newNode.parent);
        this.balance_(newNode.parent);
      }
      return (newNode || oldNode).value;
    },
    remove: function(value) {
      var retValue;

      retValue = null;
      this.traverse_(function(node) {
        var retNode;

        retNode = null;
        if (this.comparator_(node.value, value) > 0) {
          retNode = node.left;
        } else if (this.comparator_(node.value, value) < 0) {
          retNode = node.right;
        } else {
          retValue = node.value;
          this.removeNode_(node);
        }
        return retNode;
      });
      return retValue;
    },
    clear: function() {
      this.root_ = null;
      this.minNode_ = null;
      return this.maxNode_ = null;
    },
    contains: function(value) {
      return this.find(value) !== null;
    },
    find: function(value) {
      var found;

      found = null;
      this.traverse_(function(node) {
        var retNode;

        retNode = null;
        if (this.comparator_(node.value, value) > 0) {
          retNode = node.left;
        } else if (this.comparator_(node.value, value) < 0) {
          retNode = node.right;
        } else {
          found = node;
        }
        return retNode;
      });
      return found && found.value;
    },
    query: function(point) {
      var current, node, prev, result, value;

      result = [];
      node = this.root_;
      prev = null;
      current = void 0;
      value = void 0;
      while (node != null) {
        current = node;
        if (prev === node.parent) {
          if (point > node.max) {
            node = current.parent;
            prev = current;
            continue;
          }
          if (node.left != null) {
            node = current.left;
            prev = current;
            continue;
          }
          value = node.value;
          if (point < value.low) {
            node = current.parent;
            prev = current;
            continue;
          }
          if (point <= value.high) {
            result.push(value);
          }
          node = ((node.right != null) ? current.right : current.parent);
          prev = current;
          continue;
        } else {
          if (prev === node.left) {
            value = node.value;
            if (point < value.low) {
              node = current.parent;
              prev = current;
              continue;
            }
            if (point <= value.high) {
              result.push(value);
            }
            if (node.right != null) {
              node = current.right;
              prev = current;
              continue;
            }
          }
          node = current.parent;
          prev = current;
          continue;
        }
      }
      return result;
    },
    getCount: function() {
      if (this.root_) {
        return this.root_.count;
      } else {
        return 0;
      }
    },
    getKthValue: function(k) {
      if (k < 0 || k >= this.getCount()) {
        return null;
      }
      return this.getKthNode_(k).value;
    },
    getMinimum: function() {
      return this.getMinNode_().value;
    },
    getMaximum: function() {
      return this.getMaxNode_().value;
    },
    getHeight: function() {
      if (this.root_) {
        return this.root_.height;
      } else {
        return 0;
      }
    },
    getValues: function() {
      var ret;

      ret = [];
      this.inOrderTraverse(function(value) {
        return ret.push(value);
      });
      return ret;
    },
    inOrderTraverse: function(func, opt_startValue) {
      var node, prev, startNode, temp;

      if (!this.root_) {
        return;
      }
      startNode = void 0;
      if (opt_startValue) {
        this.traverse_(function(node) {
          var retNode;

          retNode = null;
          if (this.comparator_(node.value, opt_startValue) > 0) {
            retNode = node.left;
            startNode = node;
          } else if (this.comparator_(node.value, opt_startValue) < 0) {
            retNode = node.right;
          } else {
            startNode = node;
          }
          return retNode;
        });
      } else {
        startNode = this.getMinNode_();
      }
      node = startNode;
      prev = (startNode.left ? startNode.left : startNode);
      while (node != null) {
        if ((node.left != null) && node.left !== prev && node.right !== prev) {
          node = node.left;
        } else {
          if (node.right !== prev ? func(node.value) : void 0) {
            return;
          }
          temp = node;
          node = ((node.right != null) && node.right !== prev ? node.right : node.parent);
          prev = temp;
        }
      }
    },
    reverseOrderTraverse: function(func, opt_startValue) {
      var node, prev, startNode, temp;

      if (!this.root_) {
        return;
      }
      startNode = void 0;
      if (opt_startValue) {
        this.traverse_(function(node) {
          var retNode;

          retNode = null;
          if (this.comparator_(node.value, opt_startValue) > 0) {
            retNode = node.left;
          } else if (this.comparator_(node.value, opt_startValue) < 0) {
            retNode = node.right;
            startNode = node;
          } else {
            startNode = node;
          }
          return retNode;
        });
      } else {
        startNode = this.getMaxNode_();
      }
      node = startNode;
      prev = (startNode.right ? startNode.right : startNode);
      while (node != null) {
        if ((node.right != null) && node.right !== prev && node.left !== prev) {
          node = node.right;
        } else {
          if (node.left !== prev ? func(node.value) : void 0) {
            return;
          }
          temp = node;
          node = ((node.left != null) && node.left !== prev ? node.left : node.parent);
          prev = temp;
        }
      }
    },
    traverse_: function(traversalFunc, opt_startNode, opt_endNode) {
      var endNode, node, _results;

      node = (opt_startNode ? opt_startNode : this.root_);
      endNode = (opt_endNode ? opt_endNode : null);
      _results = [];
      while (node && node !== endNode) {
        _results.push(node = traversalFunc.call(this, node));
      }
      return _results;
    },
    balance_: function(node) {
      return this.traverse_((function(node) {
        var lh, rh;

        lh = (node.left ? node.left.height : 0);
        rh = (node.right ? node.right.height : 0);
        if (lh - rh > 1) {
          if (node.left.right && (!node.left.left || node.left.left.height < node.left.right.height)) {
            this.leftRotate_(node.left);
          }
          this.rightRotate_(node);
        } else if (rh - lh > 1) {
          if (node.right.left && (!node.right.right || node.right.right.height < node.right.left.height)) {
            this.rightRotate_(node.right);
          }
          this.leftRotate_(node);
        }
        lh = (node.left ? node.left.height : 0);
        rh = (node.right ? node.right.height : 0);
        node.height = Math.max(lh, rh) + 1;
        node.updateMax();
        return node.parent;
      }), node);
    },
    leftRotate_: function(node) {
      var temp;

      if (node.isLeftChild()) {
        node.parent.left = node.right;
        node.right.parent = node.parent;
      } else if (node.isRightChild()) {
        node.parent.right = node.right;
        node.right.parent = node.parent;
      } else {
        this.root_ = node.right;
        this.root_.parent = null;
      }
      temp = node.right;
      node.right = node.right.left;
      if (node.right != null) {
        node.right.parent = node;
      }
      temp.left = node;
      node.parent = temp;
      temp.count = node.count;
      node.count -= (temp.right ? temp.right.count : 0) + 1;
      return this.traverse_((function(n) {
        n.updateMax();
        if (n.parent && (n.parent.max < n.max)) {
          return n.parent;
        } else {
          return null;
        }
      }), node);
    },
    rightRotate_: function(node) {
      var temp;

      if (node.isLeftChild()) {
        node.parent.left = node.left;
        node.left.parent = node.parent;
      } else if (node.isRightChild()) {
        node.parent.right = node.left;
        node.left.parent = node.parent;
      } else {
        this.root_ = node.left;
        this.root_.parent = null;
      }
      temp = node.left;
      node.left = node.left.right;
      if (node.left != null) {
        node.left.parent = node;
      }
      temp.right = node;
      node.parent = temp;
      temp.count = node.count;
      node.count -= (temp.left ? temp.left.count : 0) + 1;
      return this.traverse_((function(n) {
        n.updateMax();
        if (n.parent && (n.parent.max < n.max)) {
          return n.parent;
        } else {
          return null;
        }
      }), node);
    },
    removeNode_: function(node) {
      var b, r;

      if ((node.left != null) || (node.right != null)) {
        b = null;
        r = void 0;
        if (node.left != null) {
          r = this.getMaxNode_(node.left);
          this.traverse_((function(node) {
            node.count--;
            return node.parent;
          }), r);
          if (r !== node.left) {
            r.parent.right = r.left;
            if (r.left) {
              r.left.parent = r.parent;
            }
            r.left = node.left;
            r.left.parent = r;
            b = r.parent;
          }
          r.parent = node.parent;
          r.right = node.right;
          if (r.right) {
            r.right.parent = r;
          }
          if (node === this.maxNode_) {
            this.maxNode_ = r;
          }
          r.count = node.count;
        } else {
          r = this.getMinNode_(node.right);
          this.traverse_((function(node) {
            node.count--;
            return node.parent;
          }), r);
          if (r !== node.right) {
            r.parent.left = r.right;
            if (r.right) {
              r.right.parent = r.parent;
            }
            r.right = node.right;
            r.right.parent = r;
            b = r.parent;
          }
          r.parent = node.parent;
          r.left = node.left;
          if (r.left) {
            r.left.parent = r;
          }
          if (node === this.minNode_) {
            this.minNode_ = r;
          }
          r.count = node.count;
        }
        if (node.isLeftChild()) {
          node.parent.left = r;
        } else if (node.isRightChild()) {
          node.parent.right = r;
        } else {
          this.root_ = r;
        }
        return this.balance_((b ? b : r));
      } else {
        this.traverse_((function(node) {
          node.count--;
          return node.parent;
        }), node.parent);
        if (node.isLeftChild()) {
          this.special = 1;
          node.parent.left = null;
          if (node === this.minNode_) {
            this.minNode_ = node.parent;
          }
          return this.balance_(node.parent);
        } else if (node.isRightChild()) {
          node.parent.right = null;
          if (node === this.maxNode_) {
            this.maxNode_ = node.parent;
          }
          return this.balance_(node.parent);
        } else {
          return this.clear();
        }
      }
    },
    getKthNode_: function(k, opt_rootNode) {
      var numNodesInLeftSubtree, root;

      root = opt_rootNode || this.root_;
      numNodesInLeftSubtree = (root.left ? root.left.count : 0);
      if (k < numNodesInLeftSubtree) {
        return this.getKthNode_(k, root.left);
      } else if (k === numNodesInLeftSubtree) {
        return root;
      } else {
        return this.getKthNode_(k - numNodesInLeftSubtree - 1, root.right);
      }
    },
    getMinNode_: function(opt_rootNode) {
      var minNode;

      if (!opt_rootNode) {
        return this.minNode_;
      }
      minNode = opt_rootNode;
      this.traverse_((function(node) {
        var retNode;

        retNode = null;
        if (node.left) {
          minNode = node.left;
          retNode = node.left;
        }
        return retNode;
      }), opt_rootNode);
      return minNode;
    },
    getMaxNode_: function(opt_rootNode) {
      var maxNode;

      if (!opt_rootNode) {
        return this.maxNode_;
      }
      maxNode = opt_rootNode;
      this.traverse_((function(node) {
        var retNode;

        retNode = null;
        if (node.right) {
          maxNode = node.right;
          retNode = node.right;
        }
        return retNode;
      }), opt_rootNode);
      return maxNode;
    }
  });

  Ext.define('Sch.lib.IntervalAvlTreeNode', {
    value: null,
    parent: null,
    left: null,
    right: null,
    height: 1,
    count: 1,
    max: null,
    constructor: function(value, parent) {
      this.value = value;
      this.parent = parent || null;
      this.max = value.high;
      return this;
    },
    isRightChild: function() {
      return !!this.parent && this.parent.right === this;
    },
    isLeftChild: function() {
      return !!this.parent && this.parent.left === this;
    },
    updateMax: function() {
      return this.max = Math.max(this.value.high, (this.left ? this.left.max : -Number.MAX_VALUE), (this.right ? this.right.max : -Number.MAX_VALUE));
    }
  });

}).call(this);

/*
//@ sourceMappingURL=IntervalAvlTree.map
*/
